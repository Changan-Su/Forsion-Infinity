# Log - 2025-01-25：启动说明与 Linux 新机清单

## 更新内容

- 在 `misskey-develop/启动说明.md` 中新增 **「零、全新 Linux 服务端快速启动」** 小节。
- 面向**全新 Linux 服务端**，从零到能访问 http://localhost:3000 的完整步骤说明。
- **全自动启动**：在本机完成 nvm、Node 22、pnpm、Docker DB、配置、依赖、构建、迁移、启动全流程。

## 实现方式

1. **环境依赖**：明确列出 Node.js 22.15.0、pnpm（corepack）、Docker + Docker Compose、FFmpeg、Git。
2. **nvm + Node 22**：apt 的 Node 版本低且无 corepack；改为用 nvm 安装 22.15.0，再 `corepack enable`，启动说明已补充示例。
3. **配置简化**：推荐使用 `example.yml` → `default.yml`，与 `docker_example.env` 一致，多数情况无需再改 db/redis。
4. **命令统一为 Linux**：`cp`、`/` 路径、`docker compose` 等，便于在 Linux 新机上直接复制执行。
5. **fluent-emojis**：本仓库 git 根在 Forsion-Infinity，`git submodule` 不作用于 `misskey-develop` 内子模块；若缺 `fluent-emojis/dist`，在 `misskey-develop` 内执行 `git clone https://github.com/misskey-dev/emojis.git fluent-emojis`。启动说明与常见问题已更新。
6. **常见问题**：补充缺 `default.yml`、数据库连接失败、端口占用、fluent-emojis、pnpm/Node 版本不符等排查提示。

## 本次已执行步骤（直接搞定）

1. `git submodule update --init`（Forsion-Infinity 根；fluent-emojis 不在根 submodule 中）。
2. 复制 `.config/docker_example.env` → `docker.env`、`example.yml` → `default.yml`。
3. `docker compose -f compose.local-db.yml up -d`（Redis、PostgreSQL 已起）。
4. 安装 nvm，`nvm install 22.15.0`，`corepack enable`。
5. `pnpm install --frozen-lockfile`、`pnpm build`。
6. 克隆 `fluent-emojis`（因 submodule 未配置），重新 `pnpm build` 通过。
7. `pnpm migrate`、`pnpm start`（后台）。服务已在 **http://localhost:3000** 监听。

## 备注

- 「一、环境准备」及「二、使用 Docker 仅跑数据库」等原有章节保留，仍适用于 Windows / 自定义配置等场景。
- 新开终端需 `nvm use 22.15.0`（或默认已切到 22）后再执行 `pnpm`；`~/.bashrc` 已加载 nvm。

## 追加记录 - 启动排障

### 问题与现象

- `pnpm dev` 启动失败，提示 `Port 3000 is already in use`。
- 随后 `pnpm dev` 报错 `Could not resolve "misskey-js"`，指向 `packages/sw/src/sw.ts` 与 `packages/sw/src/scripts/operations.ts`。

### 处理方式

1. 释放端口占用：终止占用 3000 的 Misskey 进程。
2. 补齐 `misskey-js` 构建产物：执行 `pnpm -C packages/misskey-js build` 生成 `packages/misskey-js/built/*`。
3. 验证 `sw` 构建：执行 `pnpm --filter sw build` 通过，确保能解析 `misskey-js`。

### 结论

- 端口冲突与 `misskey-js` 构建缺失会阻断 `pnpm dev`。
- 处理完毕后可重新执行 `pnpm dev` 启动。

### 追加记录 - Vite 代理 500

#### 现象

- 通过 `http://192.168.187.128:3000` 访问时，浏览器只显示一张图，控制台 `/vite/*` 资源 500。

#### 处理方式

1. 将 `.config/default.yml` 的 `url` 从 `https://example.tld/` 改为实际访问地址 `http://192.168.187.128:3000/`，避免 Vite `allowedHosts` 校验拦截。
2. 重启 `pnpm dev` 让配置重新编译生效。

### 追加记录 - 上传文件 500 错误

#### 现象

- 上传文件时报 `500 Internal Server Error`，错误信息：`column "isHtmlBundle" of relation "drive_file" does not exist`。
- `pnpm migrate` 显示 "No migrations are pending"，但数据库表结构仍缺少列。

#### 原因

- 代码模型 `DriveFile.ts` 已包含 `isHtmlBundle` 和 `htmlBundlePath` 字段，但迁移系统未检测到需要添加这些列的迁移文件。
- 可能是新功能添加了字段但迁移文件尚未创建或未正确执行。

#### 处理方式

手动执行 SQL 添加缺失列：

```sql
ALTER TABLE drive_file 
ADD COLUMN IF NOT EXISTS "isHtmlBundle" boolean NOT NULL DEFAULT false,
ADD COLUMN IF NOT EXISTS "htmlBundlePath" character varying(1024);
```

#### 结论

- 当迁移系统显示无待执行迁移但代码模型与数据库结构不一致时，需要手动检查并补齐缺失的列。
- 建议检查是否有遗漏的迁移文件，或等待上游补全迁移。

### 追加记录 - 设置页面加载失败

#### 现象

- 访问设置页面时出现 `TypeError: Cannot read properties of undefined (reading 'persisted')` 错误。
- 错误位置：`storage.ts:11:61`，在访问 `navigator.storage.persisted()` 时。

#### 原因

- `navigator.storage` API 在某些环境下不可用（如非 HTTPS、某些浏览器版本）。
- 代码直接调用 `navigator.storage.persisted()` 未做安全检查。

#### 处理方式

在 `packages/frontend/src/utility/storage.ts` 中添加安全检查：

```typescript
// 修复前
export const storagePersisted = ref(await navigator.storage.persisted());

// 修复后
export const storagePersisted = ref(await (navigator.storage?.persisted?.() ?? Promise.resolve(false)).catch(() => false));
```

同时在 `enableStoragePersistence()` 函数中添加 `navigator.storage?.persist` 的存在性检查。

#### 结论

- 使用浏览器新 API 时需要添加兼容性检查，避免在不可用环境下崩溃。
- 修复后需要重新构建前端或等待开发模式自动重载。
